% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/6-compute-scores.R
\name{computeSigScores}
\alias{computeSigScores}
\title{Compute the Summary Scores}
\usage{
computeSigScores(
  x,
  i = NULL,
  na.rm = TRUE,
  scores = c("sum", "weightedSum", "mean", "trimmedMean", "weightedMean", "median",
    "mode", "midrange", "midhinge", "trimean", "iqr", "iqm", "mad", "aad", "ssgsea",
    "gsva", "plage", "zscore"),
  scorers = NULL,
  args = NULL,
  sampling = c("none", "permutation", "bootstrap", "rndsig", "rndsigsub"),
  n.repeat = 10L,
  cores = 1L,
  logger = NULL,
  outdir = NULL,
  filename = "sigscores"
)
}
\arguments{
\item{x}{features-by-samples matrix}

\item{i}{(optional) numerical vector giving the rows
in \code{x} or character vector matching the row
names in \code{x}
If \code{missing} or \code{i = NULL}, all the rows
in \code{x} are considered for the computation of
the scores}

\item{na.rm}{logical, whether to remove \code{NA}
values before computation}

\item{scores}{(optional) character vector, indicating the
summary score(s) to compute}

\item{scorers}{named list of scoring functions.
If provided, \code{scores} is not considered.
Each function must accept some specific arguments,
i.e. \code{x}, \code{i}, \code{na.rm}, \code{...}
and is expected to compute a score for each column
in \code{x}}

\item{args}{named list, where the names must match the
\code{scores} or the names of \code{scorers}.
Each element in the list is another list
containing the arguments to pass to the function used
for computing the named score. For example,
\code{args = list(trimmedMean = list(trim = 0.4))}
indicates to use \code{trim = 0.4} when computing the
trimmed mean scores (\code{scores = "trimmedMean"} or
\code{scorers = list(trimmedMean = getScorer("trimmedMean"))})}

\item{sampling}{character string, indicating whether
to compute the scores using the provided data
(\code{sampling = "none"}, default), whether
to sample the data (\code{sampling = "permutation"}
and \code{sampling = "bootstrap"}),
or whether to generate random signatures, i.e.
vectors the same size of \code{i} with values
randomly assigned from the possible values in
\code{x}.

Five options are available:
\describe{
\item{\code{none}}{use \code{x} as it is}
\item{\code{permutation}}{random sampling without replacement from row elements of \code{x}}
\item{\code{bootstrap}}{random sampling with replacement from row elements of \code{x}}
\item{\code{rndsig}}{random signatures of same length of \code{i} generated
from all possible values in \code{x}}
\item{\code{rndsigsub}}{random signatures of same length of \code{i} generated
from all possible values in \code{x} after removing \code{i} values}
}

See \code{\link{sampleData}} and \code{\link{randomSignatures}}
for further details}

\item{n.repeat}{integer, number of repeated samples
to generate}

\item{cores}{number of cores to use for parallel execution.}

\item{logger}{(optional) a \code{\link{Logger}} object.
If provided, it will be used to report extra information
on progress. To create a Logger use \code{\link{createLogger}}}

\item{outdir}{(optional) character string, path to
the output directory. If provided the returned data
will be stored}

\item{filename}{(optional) character string, a name without
extension for the output file}
}
\value{
A data frame containing the computed
score(s) for each sample. Each row corresponds to
a different sample.

If \code{sampling = "random"}, \code{sampling = "bootstrap"},
\code{sampling = "rndsig"} or \code{sampling = "rndsigsub"},
the data frame contains a column with the run information.

The two columns containing the run/sample information are:

\describe{
\item{sampleID}{the name of the sample}
\item{run}{integer indicating in which run -
out of the \code{n.repeat} - was computed the score}
}
}
\description{
This function computes summary
score(s) of the signature \code{i} in input
considering each column vector in the input matrix
\code{x}.

A parallel execution to speed up the computation
on a multi-core machine can be run by setting
the argument \code{cores} with a number greater
than \code{1}.

See the \strong{Details} section below for further information.
}
\details{
\code{\link{computeSigScores}} uses internally
\code{\link{computeScores}} to handle the computation of
the scores.

The available scoring functions are:
\describe{
\item{\code{"sum"         }}{\code{\link{sumScorer}}}
\item{\code{"weightedSum" }}{\code{\link{weightedSumScorer}}}
\item{\code{"mean"        }}{\code{\link{meanScorer}}}
\item{\code{"trimmedMean" }}{\code{\link{trimmedMeanScorer}}}
\item{\code{"weightedMean"}}{\code{\link{weightedMeanScorer}}}
\item{\code{"median"      }}{\code{\link{medianScorer}}}
\item{\code{"mode"        }}{\code{\link{modeScorer}}}
\item{\code{"midrange"    }}{\code{\link{midrangeScorer}}}
\item{\code{"midhinge"    }}{\code{\link{midhingeScorer}}}
\item{\code{"trimean"     }}{\code{\link{trimeanScorer}}}
\item{\code{"iqr"         }}{\code{\link{iqrScorer}}}
\item{\code{"iqm"         }}{\code{\link{iqmScorer}}}
\item{\code{"mad"         }}{\code{\link{madScorer}}}
\item{\code{"aad"         }}{\code{\link{aadScorer}}}
\item{\code{"ssgsea"      }}{\code{\link{ssgseaScorer}}}
\item{\code{"gsva"        }}{\code{\link{gsvaScorer}}}
\item{\code{"plage"       }}{\code{\link{plageScorer}}}
\item{\code{"zscore"      }}{\code{\link{zscoreScorer}}}
}

Look at the different functions to know which specific
arguments they accept (arguments can be passed via the
\code{args} parameter).

Scorers also accepts a transformation function
via the \code{transform.fun} argument, which
is used to transform the data before the computation
of the scores so that:
\code{x = transform.fun(x = x, transform.args)},
where \code{transform.args} is a list of parameters passed
to the transformation function.
Look at a scorer for further details.
A transformation function and related arguments can be
passed via the \code{args} parameter (see \strong{Examples}).

The functions used for random sampling are:
\describe{
\item{\code{"permutation"}}{\code{\link{sampleData}}}
\item{\code{"bootstrap"  }}{\code{\link{sampleData}}}
\item{\code{"rndsig"     }}{\code{\link{randomSignatures}}}
\item{\code{"rndsigsub"  }}{\code{\link{randomSignatures}}}
}
}
\examples{
\dontrun{
#set seed for reproducibility
set.seed(seed = 5381L)

#Define row/col size
nr = 20
nc = 10

#Create input matrix
x = matrix(
 data = stats::runif(n = nr*nc, min = 0, max = 1000),
 nrow = nr,
 ncol = nc,
 dimnames = list(
   paste0("g",seq(nr)),
   paste0("S",seq(nc))
 )
)

#Compute all scores
computeSigScores(
 x = x,
 i = rownames(x)[1:10]
)

#Compute all scores and log
computeSigScores(
 x = x,
 i = rownames(x)[1:10],
 logger = createLogger(
   verbose = T,
   level = "DEBUG")
)

#Compute one score
computeSigScores(
 x = x,
 i = rownames(x)[1:10],
 scores = 'mean'
)

#Compute one score passing an argument
computeSigScores(
 x = x,
 i = rownames(x)[1:10],
 scores = 'trimmedMean',
 args = list(trimmedMean = list(trim = 0.2))
)

#Transform data and compute the scores
computeSigScores(
 x = x,
 i = rownames(x)[1:10],
 scorers = list(
  'score1' = getScorer('weightedSum'),
  'score2' = getScorer('trimmedMean')
 ),
 args = list(
  'score1' = list(transform.fun = getDataTransformer('quantile')),
  'score2' = list(
     trim = 0.2,
     transform.fun = getDataTransformer('stepFunction'),
     transform.args = list(
       method = 'median',
       by = 'rows'
     )
   )
 )
)

#Compute scores with permutation
computeSigScores(
 x        = x,
 i        = rownames(x)[1:10],
 sampling = "permutation",
 n.repeat = 10
)

#Compute scores with permutation;
#save log file and the results
computeSigScores(
 x        = x,
 i        = rownames(x)[1:10],
 sampling = "permutation",
 n.repeat = 10,
 logger = createLogger(
   verbose = T,
   level = "DEBUG",
   path = file.path("mydir/test/log.txt")
   ),
 outdir = "mydir/test",
 filename = "sigscores"
)

#Compute scores with bootstrap
computeSigScores(
 x        = x,
 i        = rownames(x)[1:10],
 sampling = "bootstrap",
 n.repeat = 10
)

#Compute scores with random signatures
#(elements of i are possible)
computeSigScores(
 x        = x,
 i        = rownames(x)[1:10],
 sampling = "rndsig",
 n.repeat = 10
)

#Compute scores with random signatures
#(elements of i are excluded)
computeSigScores(
 x        = x,
 i        = rownames(x)[1:10],
 sampling = "rndsigsub",
 n.repeat = 10
)

}


}
\seealso{
Use \code{\link{getAvailableScores}} to list the available
built-in scores.

Use \code{\link{getAvailableDataTransformers}} to list the available
built-in data transformers
}
\author{
Alessandro Barberis
}
